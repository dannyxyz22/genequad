#summary Research to see how much of GeneRif is covered by the n first genes

= Introduction =

Now that the most frequently reported genes have already been identified (ZipfsLaw), some research was done to find more info about them. 


== What to look for? ==

According to Dr. Simon, gene description can be found in the Entrez database (the gene_info section):

ftp://ftp.ncbi.nih.gov/gene/README

ftp://ftp.ncbi.nih.gov/gene/DATA

As Entrez database is huge, only the file [ftp://ftp.ncbi.nih.gov/gene/DATA/gene_info.gz gene_info.gz] is going to be used for now.

= Procedures =

According to the [ftp://ftp.ncbi.nih.gov/gene/README README] file, gene_info is described like this:

{{{
gene_info
---------------------------------------------------------------------------
           tab-delimited
           one line per GeneID
           Column header line is the first line in the file.
---------------------------------------------------------------------------

tax_id:
           the unique identifier provided by NCBI Taxonomy
           for the species or strain/isolate

GeneID:
           the unique identifier for a gene
           ASN1:  geneid
           --note:  for genomes previously available from LocusLink,
                    the identifiers are equivalent

Symbol:
           the default symbol for the gene
           ASN1:  gene->locus

LocusTag:
           the LocusTag value
           ASN1:  gene->locus-tag

Synonyms:
           bar-delimited set of unofficial symbols for the gene

dbXrefs:
           bar-delimited set of identifiers in other databases
           for this gene.  The unit of the set is database:value.

chromosome:
           the chromosome on which this gene is placed.
           for mitochondrial genomes, the value 'MT' is used.

map location:
           the map location for this gene

description:
           a descriptive name for this gene

type of gene:
           the type assigned to the gene according to the list of options
           provided in http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/entrezgene/entrezgene.asn


Symbol from nomenclature authority:
            when not '-', indicates that this symbol is from a
            a nomenclature authority

Full name from nomenclature authority:
            when not '-', indicates that this full name is from a
            a nomenclature authority

Nomenclature status:
            when not '-', indicates the status of the name from the 
            nomenclature authority (O for official, I for interim)

Other designations:
            pipe-delimited set of some alternate descriptions that
            have been assigned to a GeneID
            '-' indicates none is being reported.

Modification date:
            the last date a gene record was updated, in YYYYMMDD format
}}}

As it is a tab delimited file, the same approach as in ImportingGenerif was used. 
Firstly, the gene_info.db was created. The SQL statement used for that was:

{{{
create table gene_info (
id integer primary key,
 taxID integer,
geneID integer,
symbol varchar(25),
locusTag varchar(25),
synonyms varchar(25),
dbXrefs varchar(25),
chromosome varchar(25),
mapLocation varchar(25),
description text,
typeofGene varchar(25),
symbolAuthority varchar(25),
fullNameAuthority varchar(25),
nomenclatureStatus varchar(25),
otherDesignations varchar(50),
date integer);
}}}

_looking at it now, maybe, a better idea would be to create this table in the same database that had info about the genes and generifs_

The following C++ program was developed in order to import the data from gene_info ([http://genequad.googlecode.com/svn/wiki/gene_parse.cpp gene_parse.cpp]): 

{{{

#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

string replace(string test){
  string ans;
  string::size_type pos=0;
  while( (pos = test.find("\'",pos))<test.size() ){
    test.replace(pos,1,"\'\'");
    pos = pos + 2;
  }
  ans = test;
  return ans;
  
}

void Tokenize(const string& str,
                      vector<string>& tokens,
                      const string& delimiters = " ")
{
    // Skip delimiters at beginning.
    string::size_type lastPos = str.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (string::npos != pos || string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(str.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }
}


int main(){
  ifstream in("gene_info");
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}

  int count=0;

  getline(in,s);//ignore first line... only headers
  
  while(getline(in,s)){

    vector<string> fields;

    Tokenize(s,fields,"\t");


    char temp[20000];
    
    sprintf(temp,"insert into gene_info values(%d , %s , %s , '%s' , '%s', '%s','%s', '%s', '%s', '%s', '%s', '%s','%s', '%s', '%s', %s )",count++,
	    replace(fields[0]).c_str(), //taxID
	    replace(fields[1]).c_str(), //geneID
	    replace(fields[2]).c_str(), //symbol
	    replace(fields[3]).c_str(), //locusTag
	    replace(fields[4]).c_str(), //synonyms
	    replace(fields[5]).c_str(), //dbXrefs
	    replace(fields[6]).c_str(), //chromosome
	    replace(fields[7]).c_str(), //mapLocation
	    replace(fields[8]).c_str(), //description
	    replace(fields[9]).c_str(), //typeofGene
	    replace(fields[10]).c_str(),//sysmbolAuthority
	    replace(fields[11]).c_str(),//fullname
	    replace(fields[12]).c_str(),//nomenclature
	    replace(fields[13]).c_str(),//otherDesignations
	    replace(fields[14]).c_str());//date


    rc = sqlite3_exec(db,temp, NULL, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  sqlite3_close(db);
}

}}}

And it was compiled with: 
{{{
g++ gene_parse.cpp -lsqlite3 -o gene_parse
}}}

It took an Intel(R) Pentium(R) M processor at 1.70GHz around 12 hours to create the whole database. The file gene_info.db is 305MB long. According to Dr. Simon, gene databases can reach up to the Gigabytes barrier. 

After the database was created, a simple query like
{{{
select * from gene_info where geneID = 7157;
}}}

was used to retrieve info for the most frequent human gene reported in GeneRIFs. Another C++ program was created to this task, for the first 20 more frequent genes. Although it is such a simple task, the same program might be extended in order to retrieve info from more than 20 genes. The code for this file ([http://genequad.googlecode.com/svn/wiki/gene_get.cpp gene_get.cpp]) is:

{{{
#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
  int i;
  for(i=0; i<argc; i++){
    printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
  }
  printf("\n");
  return 0;
}

int main(){
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}
  
  int count=0;

  
  char temp[20000];
  vector<int> wanted;


  wanted.push_back(7157);
  wanted.push_back(7124);
  wanted.push_back(7422);
  wanted.push_back(7040);
  wanted.push_back(5743);
  wanted.push_back(3569);
  wanted.push_back(1956);
  wanted.push_back(2099);
  wanted.push_back(4790);
  wanted.push_back(3576);
  wanted.push_back(1029);
  wanted.push_back(348);
  wanted.push_back(4318);
  wanted.push_back(5468);
  wanted.push_back(351);
  wanted.push_back(3586);
  wanted.push_back(2064);
  wanted.push_back(596);
  wanted.push_back(1026);
  wanted.push_back(3479);



  for(int i=0;i<wanted.size();i++){

    sprintf(temp,"select * from gene_info where geneID = %d;",wanted[i]);    
    rc = sqlite3_exec(db,temp, callback, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  

  sqlite3_close(db);
}
}}}

Again, it was compiled with: 
{{{
g++ gene_get.cpp -lsqlite3 -o gene_get
}}}

It was run as:
{{{
./gene_get > 20first.txt
}}}

So, the file with the description of the 20 

=== Observations === 

In order to analyze statistics, RHLCCC uses the software [http://www.r-project.org/ R]. R has a similar flavor to S-plus, whereas Octave is closer to MatLab.