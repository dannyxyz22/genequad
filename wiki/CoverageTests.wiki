#summary Research to see how much of GeneRif is covered by the n first genes

= Introduction =

Now that the most frequently reported genes have already been identified (ZipfsLaw), some research was done to find more info about them. 


== What to look for? ==

According to Dr. Simon, gene description can be found in the Entrez database (the gene_info section):

ftp://ftp.ncbi.nih.gov/gene/README

ftp://ftp.ncbi.nih.gov/gene/DATA

As Entrez database is huge, only the file [ftp://ftp.ncbi.nih.gov/gene/DATA/gene_info.gz gene_info.gz] is going to be used for now.

= Procedures =

According to the [ftp://ftp.ncbi.nih.gov/gene/README README] file, gene_info is described like this:

{{{
gene_info
---------------------------------------------------------------------------
           tab-delimited
           one line per GeneID
           Column header line is the first line in the file.
---------------------------------------------------------------------------

tax_id:
           the unique identifier provided by NCBI Taxonomy
           for the species or strain/isolate

GeneID:
           the unique identifier for a gene
           ASN1:  geneid
           --note:  for genomes previously available from LocusLink,
                    the identifiers are equivalent

Symbol:
           the default symbol for the gene
           ASN1:  gene->locus

LocusTag:
           the LocusTag value
           ASN1:  gene->locus-tag

Synonyms:
           bar-delimited set of unofficial symbols for the gene

dbXrefs:
           bar-delimited set of identifiers in other databases
           for this gene.  The unit of the set is database:value.

chromosome:
           the chromosome on which this gene is placed.
           for mitochondrial genomes, the value 'MT' is used.

map location:
           the map location for this gene

description:
           a descriptive name for this gene

type of gene:
           the type assigned to the gene according to the list of options
           provided in http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/entrezgene/entrezgene.asn


Symbol from nomenclature authority:
            when not '-', indicates that this symbol is from a
            a nomenclature authority

Full name from nomenclature authority:
            when not '-', indicates that this full name is from a
            a nomenclature authority

Nomenclature status:
            when not '-', indicates the status of the name from the 
            nomenclature authority (O for official, I for interim)

Other designations:
            pipe-delimited set of some alternate descriptions that
            have been assigned to a GeneID
            '-' indicates none is being reported.

Modification date:
            the last date a gene record was updated, in YYYYMMDD format
}}}

As it is a tab delimited file, the same approach as in ImportingGenerif was used. 
Firstly, the gene_info.db was created. The SQL statement used for that was:

{{{
create table gene_info (
id integer primary key,
 taxID integer,
geneID integer,
symbol varchar(25),
locusTag varchar(25),
synonyms varchar(25),
dbXrefs varchar(25),
chromosome varchar(25),
mapLocation varchar(25),
description text,
typeofGene varchar(25),
symbolAuthority varchar(25),
fullNameAuthority varchar(25),
nomenclatureStatus varchar(25),
otherDesignations varchar(50),
date integer);
}}}

_looking at it now, maybe, a better idea would be to create this table in the same database that had info about the genes and generifs_

The following C++ program was developed in order to import the data from gene_info ([http://genequad.googlecode.com/svn/wiki/gene_parse.cpp gene_parse.cpp]): 

{{{

#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

string replace(string test){
  string ans;
  string::size_type pos=0;
  while( (pos = test.find("\'",pos))<test.size() ){
    test.replace(pos,1,"\'\'");
    pos = pos + 2;
  }
  ans = test;
  return ans;
  
}

void Tokenize(const string& str,
                      vector<string>& tokens,
                      const string& delimiters = " ")
{
    // Skip delimiters at beginning.
    string::size_type lastPos = str.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (string::npos != pos || string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(str.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }
}


int main(){
  ifstream in("gene_info");
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}

  int count=0;

  getline(in,s);//ignore first line... only headers
  
  while(getline(in,s)){

    vector<string> fields;

    Tokenize(s,fields,"\t");


    char temp[20000];
    
    sprintf(temp,"insert into gene_info values(%d , %s , %s , '%s' , '%s', '%s','%s', '%s', '%s', '%s', '%s', '%s','%s', '%s', '%s', %s )",count++,
	    replace(fields[0]).c_str(), //taxID
	    replace(fields[1]).c_str(), //geneID
	    replace(fields[2]).c_str(), //symbol
	    replace(fields[3]).c_str(), //locusTag
	    replace(fields[4]).c_str(), //synonyms
	    replace(fields[5]).c_str(), //dbXrefs
	    replace(fields[6]).c_str(), //chromosome
	    replace(fields[7]).c_str(), //mapLocation
	    replace(fields[8]).c_str(), //description
	    replace(fields[9]).c_str(), //typeofGene
	    replace(fields[10]).c_str(),//sysmbolAuthority
	    replace(fields[11]).c_str(),//fullname
	    replace(fields[12]).c_str(),//nomenclature
	    replace(fields[13]).c_str(),//otherDesignations
	    replace(fields[14]).c_str());//date


    rc = sqlite3_exec(db,temp, NULL, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  sqlite3_close(db);
}

}}}

And it was compiled with: 
{{{
g++ gene_parse.cpp -lsqlite3 -o gene_parse
}}}

It took an Intel(R) Pentium(R) M processor at 1.70GHz around 12 hours to create the whole database. The file gene_info.db is 305MB long. According to Dr. Simon, gene databases can reach up to the Gigabytes barrier. 

After the database was created, a simple query like
{{{
select * from gene_info where geneID = 7157;
}}}

was used to retrieve info for the most frequent human gene reported in GeneRIFs. Another C++ program was created to this task, for the first 20 more frequent genes. Although it is such a simple task, the same program might be extended in order to retrieve info from more than 20 genes. The code for this file ([http://genequad.googlecode.com/svn/wiki/gene_get.cpp gene_get.cpp]) is:

{{{
#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
  int i;
  for(i=0; i<argc; i++){
    printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
  }
  printf("\n");
  return 0;
}

int main(){
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}
  
  int count=0;

  
  char temp[20000];
  vector<int> wanted;


  wanted.push_back(7157);
  wanted.push_back(7124);
  wanted.push_back(7422);
  wanted.push_back(7040);
  wanted.push_back(5743);
  wanted.push_back(3569);
  wanted.push_back(1956);
  wanted.push_back(2099);
  wanted.push_back(4790);
  wanted.push_back(3576);
  wanted.push_back(1029);
  wanted.push_back(348);
  wanted.push_back(4318);
  wanted.push_back(5468);
  wanted.push_back(351);
  wanted.push_back(3586);
  wanted.push_back(2064);
  wanted.push_back(596);
  wanted.push_back(1026);
  wanted.push_back(3479);



  for(int i=0;i<wanted.size();i++){

    sprintf(temp,"select * from gene_info where geneID = %d;",wanted[i]);    
    rc = sqlite3_exec(db,temp, callback, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  

  sqlite3_close(db);
}
}}}

Again, it was compiled with: 
{{{
g++ gene_get.cpp -lsqlite3 -o gene_get
}}}

It was run as:
{{{
./gene_get > 20first.txt
}}}

So, the file with the description of the 20 first most popular genes was created as [http://genequad.googlecode.com/svn/wiki/20first.txt 20first.txt]

== How much is covered? ==

The idea to count how much geneRIF records was to make a count and limit it to only the first 100 or 500 first records, as we want. The query used was in the _generif_ database: 

{{{
select count(*) from generif where geneID in (select geneID from (select geneID, count(*) as number from generif group by geneID having taxID = 9606 order by number DESC LIMIT 100));
}}}

To check if this query makes sense, the result limited to only 1 and the number of generifs retrieved by geneID 7157 should be the same. 

So:
{{{
select count(*) from generif where geneID in (select geneID from (select geneID, count(*) as number from generif group by geneID having taxID = 9606 order by number DESC LIMIT 1)); 
1353
}}}

and
{{{
select count(*) from generif where geneID = 7157;
1353
}}}


Should be the same. And they are!

Queries limiting the first 100, 500, 1000, 5000 records have been made (changing the LIMIT number in the SQL statement) and their results are shown in the Results section.

= Results and Conclusions =

The file generated [http://genequad.googlecode.com/svn/wiki/20first.txt 20first.txt], with the description of the 20 first most frequently documented genes. 

According to Dr. Simon, these results make sense, since the top one is TP53 a gene involved in Cancer. 

== Covering percentage ==

Since *9984* distinct human genes are available (_select count(distinct geneID) from generif where taxID = 9606;_) in geneRIF and there are *105516* geneRIF records describing human genes in the same database (_select count({{{*}}}) from generif where taxID = 9606;_), these are the results retrieved from the coverage tests:

|| *Number of genes with highest frequency* || *Number of geneRIFs covered* || *Percentage of human genes covered(%)* ||
|| 1 || 1353 || 1.3 ||
|| 100 || 24901 || 23.6 || 
|| 500 || 51493 || 48.8 ||
|| 1000 || 66372 || 62.9 ||
|| 5000 || 98238 || 93.1 ||

As we have *9984* distinct human genes, around 1% of them (about 100) cover around 24% of the database, and with 5% almost half  of the database is covered. Theses results are tightly related to Zipf's law, since we can see that with only 10% we have more than 60% of the generif database covered. 

Seeing it the other way around, as stated by Dr. Simon, it can be concluded that most of the studies (as represented by # of geneRIFs) are concentrated on a few genes: 20% of geneRIFs concentrated on 1% of genes; 50% of the geneRIFs focused on 5% of the gene.

=== Observations ===

In order to analyze statistics, RHLCCC uses the software [http://www.r-project.org/ R]. R has a similar flavor to S-plus, whereas Octave is closer to MatLab.