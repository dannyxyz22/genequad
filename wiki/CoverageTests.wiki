#summary Research to see how much of GeneRif is covered by the n first genes

= Introduction =

Now that the most frequently reported genes have already been identified (ZipfsLaw), some research was done to find more info about them. 


== What to look for? ==

According to Dr. Simon, gene description can be found in the Entrez database (the gene_info section):

ftp://ftp.ncbi.nih.gov/gene/README

ftp://ftp.ncbi.nih.gov/gene/DATA

As Entrez database is huge, only the file [ftp://ftp.ncbi.nih.gov/gene/DATA/gene_info.gz gene_info.gz] is going to be used for now.

= Procedures =

According to the [ftp://ftp.ncbi.nih.gov/gene/README README] file, gene_info is described like this:

{{{
gene_info
---------------------------------------------------------------------------
           tab-delimited
           one line per GeneID
           Column header line is the first line in the file.
---------------------------------------------------------------------------

tax_id:
           the unique identifier provided by NCBI Taxonomy
           for the species or strain/isolate

GeneID:
           the unique identifier for a gene
           ASN1:  geneid
           --note:  for genomes previously available from LocusLink,
                    the identifiers are equivalent

Symbol:
           the default symbol for the gene
           ASN1:  gene->locus

LocusTag:
           the LocusTag value
           ASN1:  gene->locus-tag

Synonyms:
           bar-delimited set of unofficial symbols for the gene

dbXrefs:
           bar-delimited set of identifiers in other databases
           for this gene.  The unit of the set is database:value.

chromosome:
           the chromosome on which this gene is placed.
           for mitochondrial genomes, the value 'MT' is used.

map location:
           the map location for this gene

description:
           a descriptive name for this gene

type of gene:
           the type assigned to the gene according to the list of options
           provided in http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/entrezgene/entrezgene.asn


Symbol from nomenclature authority:
            when not '-', indicates that this symbol is from a
            a nomenclature authority

Full name from nomenclature authority:
            when not '-', indicates that this full name is from a
            a nomenclature authority

Nomenclature status:
            when not '-', indicates the status of the name from the 
            nomenclature authority (O for official, I for interim)

Other designations:
            pipe-delimited set of some alternate descriptions that
            have been assigned to a GeneID
            '-' indicates none is being reported.

Modification date:
            the last date a gene record was updated, in YYYYMMDD format
}}}

As it is a tab delimited file, the same approach as in ImportingGenerif was used. The following C++ program was developed in order to import the data from gene_info ([http://genequad.googlecode.com/svn/wiki/gene_parse.cpp gene_parse.cpp]): 

{{{

#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

string replace(string test){
  string ans;
  string::size_type pos=0;
  while( (pos = test.find("\'",pos))<test.size() ){
    test.replace(pos,1,"\'\'");
    pos = pos + 2;
  }
  ans = test;
  return ans;
  
}

void Tokenize(const string& str,
                      vector<string>& tokens,
                      const string& delimiters = " ")
{
    // Skip delimiters at beginning.
    string::size_type lastPos = str.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (string::npos != pos || string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(str.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }
}


int main(){
  ifstream in("gene_info");
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}

  int count=0;

  getline(in,s);//ignore first line... only headers
  
  while(getline(in,s)){

    vector<string> fields;

    Tokenize(s,fields,"\t");


    char temp[20000];
    
    sprintf(temp,"insert into gene_info values(%d , %s , %s , '%s' , '%s', '%s','%s', '%s', '%s', '%s', '%s', '%s','%s', '%s', '%s', %s )",count++,
	    replace(fields[0]).c_str(), //taxID
	    replace(fields[1]).c_str(), //geneID
	    replace(fields[2]).c_str(), //symbol
	    replace(fields[3]).c_str(), //locusTag
	    replace(fields[4]).c_str(), //synonyms
	    replace(fields[5]).c_str(), //dbXrefs
	    replace(fields[6]).c_str(), //chromosome
	    replace(fields[7]).c_str(), //mapLocation
	    replace(fields[8]).c_str(), //description
	    replace(fields[9]).c_str(), //typeofGene
	    replace(fields[10]).c_str(),//sysmbolAuthority
	    replace(fields[11]).c_str(),//fullname
	    replace(fields[12]).c_str(),//nomenclature
	    replace(fields[13]).c_str(),//otherDesignations
	    replace(fields[14]).c_str());//date


    rc = sqlite3_exec(db,temp, NULL, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  sqlite3_close(db);
}

}}}



{{{
#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include <sqlite3.h>



using namespace std;

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
  int i;
  for(i=0; i<argc; i++){
    printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
  }
  printf("\n");
  return 0;
}

int main(){
  string s;
  string::size_type pos = 0;

  sqlite3 *db;
  char* zErrMsg = 0;
  int rc = sqlite3_open("gene_info.db",&db);
  if(rc) {printf("bugged\n");return 0;}
  
  int count=0;

  
  char temp[20000];
  vector<int> wanted;


  wanted.push_back(7157);
  wanted.push_back(7124);
  wanted.push_back(7422);
  wanted.push_back(7040);
  wanted.push_back(5743);
  wanted.push_back(3569);
  wanted.push_back(1956);
  wanted.push_back(2099);
  wanted.push_back(4790);
  wanted.push_back(3576);
  wanted.push_back(1029);
  wanted.push_back(348);
  wanted.push_back(4318);
  wanted.push_back(5468);
  wanted.push_back(351);
  wanted.push_back(3586);
  wanted.push_back(2064);
  wanted.push_back(596);
  wanted.push_back(1026);
  wanted.push_back(3479);



  for(int i=0;i<wanted.size();i++){

    sprintf(temp,"select * from gene_info where geneID = %d;",wanted[i]);    
    rc = sqlite3_exec(db,temp, callback, 0, &zErrMsg);
    if( rc!=SQLITE_OK){
      fprintf(stderr, "SQL error: %s\n",zErrMsg);
      fprintf(stderr, "Blamed string: %s\n",temp);
      sqlite3_free(zErrMsg);
    }

  }
  

  sqlite3_close(db);
}
}}}

Again, it was compiled with: 
{{{
g++ gene_get.cpp -lsqlite3
}}}



=== Observations === 

In order to analyze statistics, RHLCCC uses the software [http://www.r-project.org/ R]. R has a similar flavor to S-plus, whereas Octave is closer to MatLab.