#summary how to import a GeneRIF database to sqlite3

= Importing GeneRIF database to sqlite3 =

The first task assigned was to import GeneRIF plain text descriptions into a database. It is located at:

http://www.ncbi.nlm.nih.gov/projects/GeneRIF/
ftp://ftp.ncbi.nih.gov/gene/

As pointed by Dr. Simon, SQLite (http://www.sqlite.org/) is preferred, because RHLCCC has other projects using it, so later they can be easily integrated.

Firstly, the files  README  (ftp://ftp.ncbi.nih.gov/gene/README) and generifs_basic.gz ( ftp://ftp.ncbi.nih.gov/gene/GeneRIF/generifs_basic.gz) were downloaded in 21-MAY-2007.

After that it was noticed that a couple lines from generifs_basic had more than one pubmed id - as it is said in README, "PubMed ID (PMID) list unique citation identifier(s) in PubMed; multiple values are comma-separated". So, in order to handle that issue, these records were duplicated. For instance, the line 26310, in which the line:

||9606||708||1830244,8262387,8567680||2004-05-11||13:09||This protein has also been identified as the p32 subunit of pre-mRNA splicing factor SF2, as well as a hyaluronic acid-binding protein||

became three records:

||9606||708||1830244||2004-05-11||13:09||This protein has also been identified as the p32 subunit of pre-mRNA splicing factor SF2, as well as a hyaluronic acid-binding protein||
||9606||708||8262387||2004-05-11||13:09||This protein has also been identified as the p32 subunit of pre-mRNA splicing factor SF2, as well as a hyaluronic acid-binding protein||
||9606||708||8567680||2004-05-11||13:09||This protein has also been identified as the p32 subunit of pre-mRNA splicing factor SF2, as well as a hyaluronic acid-binding protein||

This way, fast access is granted for the PubMedID field, now stored as integer.
The database was created with the following SQL statement:
{{{
create table generif (
id integer primary key,
 taxID integer,
geneID integer,
pmID integer,
updateDay varchar(20),
updateHour varchar(8),
description text
);
}}}

If the  'text' type isn't as fast as a varchar(300), for instance, it can be later changed.

After that, generifs_basic was parsed and added to the database, through the following c++ program:
{{{
#include <stdio.h>
#include <iostream>
#include <sstream>
#include <string>
#include <sqlite3.h>


using namespace std;

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
  int i;
  for(i=0; i<argc; i++){
    printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
  }
  printf("\n");
  return 0;
}

int main(){
  int taxID,geneID,ipubID;
  char pubID[1000],datestamp[1000],hourstamp[1000],description[1000],pdescription[1100];
  int count=0;
  while( scanf("%d%d%s%s%s\t",&taxID,&geneID,pubID,datestamp,hourstamp) !=EOF){
    gets(description);
    int start = 0;

    int shift=0;
    int pos=0;
    for(pos=0;description[pos]!=0;pos++){
      if(description[pos]=='\''){
	pdescription[pos+shift] = '\'';
	pdescription[pos+shift+1] = '\'';
	shift++;
      }
      else
	pdescription[pos+shift] =  description[pos];
    }
    pdescription[pos+shift]=0; 
    

    int comma=0;
    for(int i=0;pubID[i]!=0;i++){
      if(pubID[i]==',') comma++;
    }

    //database
    sqlite3 *db;
    char* zErrMsg = 0;
    int rc = sqlite3_open("genetest",&db);
    if(rc) {printf("bugged\n");return 0;}


    string spubID;
    spubID += string(pubID);
    istringstream stream(spubID);
    int first=1;
    for(int i=0;i<=comma;i++){
      if(first){ //first time does not need to get commas
	first = 0;
	stream >> ipubID;
      }
      else{
	char dummy;
	stream >> dummy; //only to read comma
	stream >> ipubID;
      }


      char temp[2000];
      
      sprintf(temp,"insert into generif values(%d , %d , %d , %d, '%s', '%s','%s' )",count++,taxID,geneID,ipubID,datestamp,hourstamp,pdescription);
      rc = sqlite3_exec(db,temp, callback, 0, &zErrMsg);
      if( rc!=SQLITE_OK){
	fprintf(stderr, "SQL error: %s\n",zErrMsg);
	fprintf(stderr, "Blamed string: %s\n",temp);
	sqlite3_free(zErrMsg);
      }
    }
    
    sqlite3_close(db);
  }
}

}}}

It can refactored, if it's going to be necessary.

The following line was used to compile the program (under Fedora linux)
{{{
g++ conv.cpp -I /usr/include -lsqlite3 -o convert
}}}

It warns about a 'gets' dangerous function, but that's only because gets doesn't check buffer for overflow. But the buffer is big enough not to cause anyone troubles.
Finally, it was run as:
{{{
convert < generifs_basic
}}}

And, after around 10 minutes, a file of about 40MB was created

== Validation of the results ==

It was asked by Dr. Simon to query the database and find the total number of geneRIFs and the total number of distinct publications. It should be close (but not exactly) to the number reported by the NCBI:
http://www.ncbi.nlm.nih.gov/projects/GeneRIF/stats/

=== Results ===

||*Number* *of* *geneRIFs* *imported*||*Number of geneRIFs reported by NCBI*||*sql query*||
||162725||198159||select count(distinct description) from generif||
||*Number of distinct publications imported*||*Number of distinct publications reported by NCBI*||*sql query*||
||141392||137406||select count(distinct pmID) from generif;||


=== Remarks ====

If the query ( select count(*) from generif) , which is, the number of records, is executed, the result is 203,263.

The number of lines in generifs_basic is 203,235. That's ok, because the records that refered more than one pubMed were just a few, about 30 records, that's why there are more records in the table than generifs_basic's.
It is just weird that the number of geneRIFs is so different from the number of lines. I thought they should be the same. 

The difference between results acquired and the ones published by NCBI might be due to small differences in descriptions, such as one point or comma like in the records:

"-16 E5 protein can form a complex with ErbB4 via binding to the
extracellular and transmembrane domains of ErbB4 (JM-b/CYT-1)" 
and
"-16 E5 protein can form a complex with ErbB4 via binding to the
extracellular and transmembrane domains of ErbB4 (JM-b/CYT-1)." 

which would yield different records in the query "select count(distinct description) from generif". Although there are 2 different genes described in these records, it is counted twice by the queries used.

On the other hand, one gene can have multiple RIFs (sentences), and one RIF can discuss multiple genes. That is why duplicated RIFs might appear.

The number of publications is very close (2.9%).